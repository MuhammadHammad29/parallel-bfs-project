Parallel BFS — Sequential vs Parallel Performance Results

Graph Configuration Notes:
- Algorithm: Breadth-First Search (level-synchronous, OpenMP)
- Graph Type: Random undirected synthetic graph (make_synthetic_graph)
- Platform: Windows (PowerShell), compiled with g++ -O3 -fopenmp
- Objective: Evaluate correctness and preliminary performance improvements for mid-term submission.

---------------------------------------------------------------------
Test 1 — Small Graph (n = 10,000, deg = 8)
---------------------------------------------------------------------
Threads=1
Seq_time_s=0.001000
Par_time_s=0.001000
Speedup=1.000000
Level_check=OK
Visited_seq=10000 Visited_par=10000

Threads=4
Seq_time_s=0.001000
Par_time_s=0.004000
Speedup=0.249985
Level_check=OK
Visited_seq=10000 Visited_par=10000

Observation:
On small graphs, thread creation and synchronization overhead outweighs the computational work.
Parallelization shows no gain yet, which is expected.
Correctness confirmed (Level_check=OK).

---------------------------------------------------------------------
Test 2 — Medium Graph (n = 200,000, deg = 8)
---------------------------------------------------------------------
Threads=1
Seq_time_s=0.025000
Par_time_s=0.037000
Speedup=0.675679
Level_check=OK
Visited_seq=200000 Visited_par=200000

Threads=2
Seq_time_s=0.024000
Par_time_s=0.031000
Speedup=0.774188
Level_check=OK
Visited_seq=200000 Visited_par=200000

Threads=4
Seq_time_s=0.026000
Par_time_s=0.024000
Speedup=1.083337
Level_check=OK
Visited_seq=200000 Visited_par=200000

Threads=8
Seq_time_s=0.026000
Par_time_s=0.019000
Speedup=1.368418
Level_check=OK
Visited_seq=200000 Visited_par=200000

Observation:
As node count increases, parallel performance improves.
Speedup grows with thread count, reaching 1.37× at 8 threads.
Minor inefficiencies due to atomic operations and memory contention.
Correctness is consistent across all runs.

---------------------------------------------------------------------
Preliminary Performance Analysis
---------------------------------------------------------------------
- All results confirm correctness (Level_check=OK).
- Small dataset: negligible or negative speedup due to overhead.
- Medium dataset: clear improvement from 1→8 threads (1.08×–1.37×).
- Main bottlenecks:
  • Synchronization on atomic visited[] array.
  • Load imbalance between threads.
  • Memory-bandwidth contention.
- Expected improvements:
  • Higher degree or larger graph will yield better parallel efficiency.

---------------------------------------------------------------------
Summary Table
---------------------------------------------------------------------
| Graph Size | Avg Deg | Threads | Seq_time_s | Par_time_s | Speedup | Level_check |
|-------------|----------|----------|-------------|-------------|-----------|--------------|
| 10,000 | 8 | 1 | 0.001000 | 0.001000 | 1.00× | OK |
| 10,000 | 8 | 4 | 0.001000 | 0.004000 | 0.25× | OK |
| 200,000 | 8 | 1 | 0.025000 | 0.037000 | 0.68× | OK |
| 200,000 | 8 | 2 | 0.024000 | 0.031000 | 0.77× | OK |
| 200,000 | 8 | 4 | 0.026000 | 0.024000 | 1.08× | OK |
| 200,000 | 8 | 8 | 0.026000 | 0.019000 | 1.37× | OK |

---------------------------------------------------------------------
Mid-Term Summary
---------------------------------------------------------------------
The BFS project fulfills mid-term deliverables:
- Functional sequential implementation ✅
- Partially working OpenMP parallel version ✅
- Timing and speedup analysis ✅
- Correctness verification via Level_check ✅
